// Generated by typings
// Source: https://raw.githubusercontent.com/aurelia/validation/0.13.1/dist/amd/validate-binding-behavior-base.d.ts
declare module '~aurelia-validation/dist/amd/validate-binding-behavior-base' {
import { TaskQueue } from 'aurelia-task-queue';
import { ValidationController } from '~aurelia-validation/dist/amd/validation-controller';
/**
 * Binding behavior. Indicates the bound property should be validated.
 */
export abstract class ValidateBindingBehaviorBase {
    private taskQueue;
    constructor(taskQueue: TaskQueue);
    protected abstract getValidateTrigger(controller: ValidationController): number;
    /**
    * Gets the DOM element associated with the data-binding. Most of the time it's
    * the binding.target but sometimes binding.target is an aurelia custom element,
    * or custom attribute which is a javascript "class" instance, so we need to use
    * the controller's container to retrieve the actual DOM element.
    */
    getTarget(binding: any, view: any): any;
    bind(binding: any, source: any, rulesOrController?: ValidationController | any, rules?: any): void;
    unbind(binding: any): void;
}
}
declare module 'aurelia-validation/dist/amd/validate-binding-behavior-base' {
export * from '~aurelia-validation/dist/amd/validate-binding-behavior-base';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/aurelia/validation/0.13.1/dist/amd/validate-binding-behavior.d.ts
declare module '~aurelia-validation/dist/amd/validate-binding-behavior' {
import { TaskQueue } from 'aurelia-task-queue';
import { ValidationController } from '~aurelia-validation/dist/amd/validation-controller';
import { ValidateBindingBehaviorBase } from '~aurelia-validation/dist/amd/validate-binding-behavior-base';
/**
 * Binding behavior. Indicates the bound property should be validated
 * when the validate trigger specified by the associated controller's
 * validateTrigger property occurs.
 */
export class ValidateBindingBehavior extends ValidateBindingBehaviorBase {
    static inject: typeof TaskQueue[];
    getValidateTrigger(controller: ValidationController): number;
}
/**
 * Binding behavior. Indicates the bound property will be validated
 * manually, by calling controller.validate(). No automatic validation
 * triggered by data-entry or blur will occur.
 */
export class ValidateManuallyBindingBehavior extends ValidateBindingBehaviorBase {
    static inject: typeof TaskQueue[];
    getValidateTrigger(): number;
}
/**
 * Binding behavior. Indicates the bound property should be validated
 * when the associated element blurs.
 */
export class ValidateOnBlurBindingBehavior extends ValidateBindingBehaviorBase {
    static inject: typeof TaskQueue[];
    getValidateTrigger(): number;
}
/**
 * Binding behavior. Indicates the bound property should be validated
 * when the associated element is changed by the user, causing a change
 * to the model.
 */
export class ValidateOnChangeBindingBehavior extends ValidateBindingBehaviorBase {
    static inject: typeof TaskQueue[];
    getValidateTrigger(): number;
}
/**
 * Binding behavior. Indicates the bound property should be validated
 * when the associated element blurs or is changed by the user, causing
 * a change to the model.
 */
export class ValidateOnChangeOrBlurBindingBehavior extends ValidateBindingBehaviorBase {
    static inject: typeof TaskQueue[];
    getValidateTrigger(): number;
}
}
declare module 'aurelia-validation/dist/amd/validate-binding-behavior' {
export * from '~aurelia-validation/dist/amd/validate-binding-behavior';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/aurelia/validation/0.13.1/dist/amd/validate-trigger.d.ts
declare module '~aurelia-validation/dist/amd/validate-trigger' {
/**
* Validation triggers.
*/
export const validateTrigger: {
    manual: number;
    blur: number;
    change: number;
    changeOrBlur: number;
};
}
declare module 'aurelia-validation/dist/amd/validate-trigger' {
export * from '~aurelia-validation/dist/amd/validate-trigger';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/aurelia/validation/0.13.1/dist/amd/validation-controller.d.ts
declare module '~aurelia-validation/dist/amd/validation-controller' {
import { Binding } from 'aurelia-binding';
import { Validator } from '~aurelia-validation/dist/amd/validator';
import { ValidationRenderer } from '~aurelia-validation/dist/amd/validation-renderer';
import { ValidationError } from '~aurelia-validation/dist/amd/validation-error';
export interface ValidateInstruction {
    /**
     * The object to validate.
     */
    object: any;
    /**
     * The property to validate. Optional.
     */
    propertyName?: any;
    /**
     * The rules to validate. Optional.
     */
    rules?: any;
}
/**
 * Orchestrates validation.
 * Manages a set of bindings, renderers and objects.
 * Exposes the current list of validation errors for binding purposes.
 */
export class ValidationController {
    private validator;
    static inject: typeof Validator[];
    private bindings;
    private renderers;
    /**
     * Errors that have been rendered by the controller.
     */
    errors: ValidationError[];
    /**
     *  Whether the controller is currently validating.
     */
    validating: boolean;
    private elements;
    private objects;
    /**
     * The trigger that will invoke automatic validation of a property used in a binding.
     */
    validateTrigger: number;
    private finishValidating;
    constructor(validator: Validator);
    /**
     * Adds an object to the set of objects that should be validated when validate is called.
     * @param object The object.
     * @param rules Optional. The rules. If rules aren't supplied the Validator implementation will lookup the rules.
     */
    addObject(object: any, rules?: any): void;
    /**
     * Removes an object from the set of objects that should be validated when validate is called.
     * @param object The object.
     */
    removeObject(object: any): void;
    /**
     * Adds and renders a ValidationError.
     */
    addError(message: string, object: any, propertyName?: string): ValidationError;
    /**
     * Removes and unrenders a ValidationError.
     */
    removeError(error: ValidationError): void;
    /**
     * Adds a renderer.
     * @param renderer The renderer.
     */
    addRenderer(renderer: ValidationRenderer): void;
    /**
     * Removes a renderer.
     * @param renderer The renderer.
     */
    removeRenderer(renderer: ValidationRenderer): void;
    /**
     * Registers a binding with the controller.
     * @param binding The binding instance.
     * @param target The DOM element.
     * @param rules (optional) rules associated with the binding. Validator implementation specific.
     */
    registerBinding(binding: Binding, target: Element, rules?: any): void;
    /**
     * Unregisters a binding with the controller.
     * @param binding The binding instance.
     */
    unregisterBinding(binding: Binding): void;
    /**
     * Interprets the instruction and returns a predicate that will identify
     * relevant errors in the list of rendered errors.
     */
    private getInstructionPredicate(instruction?);
    /**
     * Validates and renders errors.
     * @param instruction Optional. Instructions on what to validate. If undefined, all objects and bindings will be validated.
     */
    validate(instruction?: ValidateInstruction): Promise<ValidationError[]>;
    /**
     * Resets any rendered errors (unrenders).
     * @param instruction Optional. Instructions on what to reset. If unspecified all rendered errors will be unrendered.
     */
    reset(instruction?: ValidateInstruction): void;
    /**
     * Gets the elements associated with an object and propertyName (if any).
     */
    private getAssociatedElements({object, propertyName});
    private processErrorDelta(kind, oldErrors, newErrors);
    /**
    * Validates the property associated with a binding.
    */
    validateBinding(binding: Binding): void;
    /**
    * Resets the errors for a property associated with a binding.
    */
    resetBinding(binding: Binding): void;
}
}
declare module 'aurelia-validation/dist/amd/validation-controller' {
export * from '~aurelia-validation/dist/amd/validation-controller';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/aurelia/validation/0.13.1/dist/amd/validation-controller-factory.d.ts
declare module '~aurelia-validation/dist/amd/validation-controller-factory' {
import { Container } from 'aurelia-dependency-injection';
import { ValidationController } from '~aurelia-validation/dist/amd/validation-controller';
import { Validator } from '~aurelia-validation/dist/amd/validator';
/**
 * Creates ValidationController instances.
 */
export class ValidationControllerFactory {
    private container;
    static get(container: Container): ValidationControllerFactory;
    constructor(container: Container);
    /**
     * Creates a new controller instance.
     */
    create(validator?: Validator): ValidationController;
    /**
     * Creates a new controller and registers it in the current element's container so that it's
     * available to the validate binding behavior and renderers.
     */
    createForCurrentScope(validator?: Validator): ValidationController;
}
}
declare module 'aurelia-validation/dist/amd/validation-controller-factory' {
export * from '~aurelia-validation/dist/amd/validation-controller-factory';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/aurelia/validation/0.13.1/dist/amd/validation-error.d.ts
declare module '~aurelia-validation/dist/amd/validation-error' {
/**
 * A validation error.
 */
export class ValidationError {
    rule: any;
    message: string;
    object: any;
    propertyName: string | null;
    private static nextId;
    /**
     * A number that uniquely identifies the error instance.
     */
    id: number;
    /**
     * @param rule The rule associated with the error. Validator implementation specific.
     * @param message The error message.
     * @param object The invalid object
     * @param propertyName The name of the invalid property. Optional.
     */
    constructor(rule: any, message: string, object: any, propertyName?: string | null);
    toString(): string;
}
}
declare module 'aurelia-validation/dist/amd/validation-error' {
export * from '~aurelia-validation/dist/amd/validation-error';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/aurelia/validation/0.13.1/dist/amd/validation-errors-custom-attribute.d.ts
declare module '~aurelia-validation/dist/amd/validation-errors-custom-attribute' {
import { Lazy } from 'aurelia-dependency-injection';
import { ValidationController } from '~aurelia-validation/dist/amd/validation-controller';
import { ValidationError } from '~aurelia-validation/dist/amd/validation-error';
import { ValidationRenderer, RenderInstruction } from '~aurelia-validation/dist/amd/validation-renderer';
export interface RenderedError {
    error: ValidationError;
    targets: Element[];
}
export class ValidationErrorsCustomAttribute implements ValidationRenderer {
    private boundaryElement;
    private controllerAccessor;
    static inject: ({
        new (): Element;
        prototype: Element;
    } | Lazy)[];
    value: RenderedError[];
    errors: RenderedError[];
    constructor(boundaryElement: Element, controllerAccessor: {
        (): ValidationController;
    });
    sort(): void;
    interestingElements(elements: Element[]): Element[];
    render(instruction: RenderInstruction): void;
    bind(): void;
    unbind(): void;
}
}
declare module 'aurelia-validation/dist/amd/validation-errors-custom-attribute' {
export * from '~aurelia-validation/dist/amd/validation-errors-custom-attribute';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/aurelia/validation/0.13.1/dist/amd/validation-renderer-custom-attribute.d.ts
declare module '~aurelia-validation/dist/amd/validation-renderer-custom-attribute' {
export class ValidationRendererCustomAttribute {
    private container;
    private controller;
    private value;
    private renderer;
    created(view: any): void;
    bind(): void;
    unbind(): void;
}
}
declare module 'aurelia-validation/dist/amd/validation-renderer-custom-attribute' {
export * from '~aurelia-validation/dist/amd/validation-renderer-custom-attribute';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/aurelia/validation/0.13.1/dist/amd/validation-renderer.d.ts
declare module '~aurelia-validation/dist/amd/validation-renderer' {
import { ValidationError } from '~aurelia-validation/dist/amd/validation-error';
/**
 * An error to render (or unrender) and the associated elements (if any)
 */
export interface RenderErrorInstruction {
    /**
     * The validation error.
     */
    error: ValidationError;
    /**
     * The associated elements (if any).
     */
    elements: Element[];
}
/**
 * Defines which errors to render and which errors to unrender.
 */
export interface RenderInstruction {
    /**
     * The "kind" of render instruction. Either 'validate' or 'reset'.
     */
    kind: 'validate' | 'reset';
    /**
     * The errors to render.
     */
    render: RenderErrorInstruction[];
    /**
     * The errors to unrender.
     */
    unrender: RenderErrorInstruction[];
}
/**
 * Renders validation errors.
 */
export interface ValidationRenderer {
    /**
     * Render the errors.
     * @param instruction The render instruction. Defines which errors to render and which
     * errors to unrender.
     */
    render(instruction: RenderInstruction): void;
}
}
declare module 'aurelia-validation/dist/amd/validation-renderer' {
export * from '~aurelia-validation/dist/amd/validation-renderer';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/aurelia/validation/0.13.1/dist/amd/validator.d.ts
declare module '~aurelia-validation/dist/amd/validator' {
import { ValidationError } from '~aurelia-validation/dist/amd/validation-error';
/**
 * Validates.
 * Responsible for validating objects and properties.
 */
export abstract class Validator {
    /**
     * Validates the specified property.
     * @param object The object to validate.
     * @param propertyName The name of the property to validate.
     * @param rules Optional. If unspecified, the implementation should lookup the rules for the
     * specified object. This may not be possible for all implementations of this interface.
     */
    abstract validateProperty(object: any, propertyName: string, rules?: any): Promise<ValidationError[]>;
    /**
     * Validates all rules for specified object and it's properties.
     * @param object The object to validate.
     * @param rules Optional. If unspecified, the implementation should lookup the rules for the
     * specified object. This may not be possible for all implementations of this interface.
     */
    abstract validateObject(object: any, rules?: any): Promise<ValidationError[]>;
}
}
declare module 'aurelia-validation/dist/amd/validator' {
export * from '~aurelia-validation/dist/amd/validator';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/aurelia/validation/0.13.1/dist/amd/implementation/rule.d.ts
declare module '~aurelia-validation/dist/amd/implementation/rule' {
import { Expression } from 'aurelia-binding';
/**
 * Information related to a property that is the subject of validation.
 */
export interface RuleProperty {
    /**
     * The property name. null indicates the rule targets the object itself.
     */
    name: string | null;
    /**
     * The displayName of the property (or object).
     */
    displayName: string | null;
}
/**
 * A rule definition. Associations a rule with a property or object.
 */
export interface Rule<TObject, TValue> {
    property: RuleProperty;
    condition: (value: TValue, object?: TObject) => boolean | Promise<boolean>;
    config: Object;
    when: {
        (object: TObject): boolean;
    } | null;
    messageKey: string;
    message: Expression | null;
    sequence: number;
    tag?: string;
}
}
declare module 'aurelia-validation/dist/amd/implementation/rule' {
export * from '~aurelia-validation/dist/amd/implementation/rule';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/aurelia/validation/0.13.1/dist/amd/implementation/rules.d.ts
declare module '~aurelia-validation/dist/amd/implementation/rules' {
import { Rule } from '~aurelia-validation/dist/amd/implementation/rule';
/**
 * Sets, unsets and retrieves rules on an object or constructor function.
 */
export class Rules {
    /**
     * The name of the property that stores the rules.
     */
    static key: string;
    /**
     * Applies the rules to a target.
     */
    static set(target: any, rules: Rule<any, any>[][]): void;
    /**
     * Removes rules from a target.
     */
    static unset(target: any): void;
    /**
     * Retrieves the target's rules.
     */
    static get(target: any): Rule<any, any>[][] | null;
}
}
declare module 'aurelia-validation/dist/amd/implementation/rules' {
export * from '~aurelia-validation/dist/amd/implementation/rules';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/aurelia/validation/0.13.1/dist/amd/implementation/standard-validator.d.ts
declare module '~aurelia-validation/dist/amd/implementation/standard-validator' {
import { ViewResources } from 'aurelia-templating';
import { Validator } from '~aurelia-validation/dist/amd/validator';
import { ValidationError } from '~aurelia-validation/dist/amd/validation-error';
import { ValidationMessageProvider } from '~aurelia-validation/dist/amd/implementation/validation-messages';
/**
 * Validates.
 * Responsible for validating objects and properties.
 */
export class StandardValidator extends Validator {
    static inject: (typeof ValidationMessageProvider | typeof ViewResources)[];
    private messageProvider;
    private lookupFunctions;
    private getDisplayName;
    constructor(messageProvider: ValidationMessageProvider, resources: ViewResources);
    private getMessage(rule, object, value);
    private validateRuleSequence(object, propertyName, ruleSequence, sequence);
    private validate(object, propertyName, rules);
    /**
     * Validates the specified property.
     * @param object The object to validate.
     * @param propertyName The name of the property to validate.
     * @param rules Optional. If unspecified, the rules will be looked up using the metadata
     * for the object created by ValidationRules....on(class/object)
     */
    validateProperty(object: any, propertyName: string, rules?: any): Promise<ValidationError[]>;
    /**
     * Validates all rules for specified object and it's properties.
     * @param object The object to validate.
     * @param rules Optional. If unspecified, the rules will be looked up using the metadata
     * for the object created by ValidationRules....on(class/object)
     */
    validateObject(object: any, rules?: any): Promise<ValidationError[]>;
}
}
declare module 'aurelia-validation/dist/amd/implementation/standard-validator' {
export * from '~aurelia-validation/dist/amd/implementation/standard-validator';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/aurelia/validation/0.13.1/dist/amd/implementation/validation-messages.d.ts
declare module '~aurelia-validation/dist/amd/implementation/validation-messages' {
import { Expression } from 'aurelia-binding';
import { ValidationParser } from '~aurelia-validation/dist/amd/implementation/validation-parser';
export interface ValidationMessages {
    [key: string]: string;
}
/**
 * Dictionary of validation messages. [messageKey]: messageExpression
 */
export const validationMessages: ValidationMessages;
/**
 * Retrieves validation messages and property display names.
 */
export class ValidationMessageProvider {
    private parser;
    static inject: typeof ValidationParser[];
    constructor(parser: ValidationParser);
    /**
     * Returns a message binding expression that corresponds to the key.
     * @param key The message key.
     */
    getMessage(key: string): Expression;
    /**
     * When a display name is not provided, this method is used to formulate
     * a display name using the property name.
     * Override this with your own custom logic.
     * @param propertyName The property name.
     */
    getDisplayName(propertyName: string): string;
}
}
declare module 'aurelia-validation/dist/amd/implementation/validation-messages' {
export * from '~aurelia-validation/dist/amd/implementation/validation-messages';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/aurelia/validation/0.13.1/dist/amd/implementation/validation-parser.d.ts
declare module '~aurelia-validation/dist/amd/implementation/validation-parser' {
import { Parser, Expression, AccessScope, Unparser } from 'aurelia-binding';
import { BindingLanguage } from 'aurelia-templating';
import { RuleProperty } from '~aurelia-validation/dist/amd/implementation/rule';
export interface PropertyAccessor<TObject, TValue> {
    (object: TObject): TValue;
}
export class ValidationParser {
    private parser;
    private bindinqLanguage;
    static inject: (typeof Parser | typeof BindingLanguage)[];
    private emptyStringExpression;
    private nullExpression;
    private undefinedExpression;
    private cache;
    constructor(parser: Parser, bindinqLanguage: BindingLanguage);
    private coalesce(part);
    parseMessage(message: string): Expression;
    private getAccessorExpression(fn);
    parseProperty<TObject, TValue>(property: string | PropertyAccessor<TObject, TValue>): RuleProperty;
}
export class MessageExpressionValidator extends Unparser {
    private originalMessage;
    static validate(expression: Expression, originalMessage: string): void;
    constructor(originalMessage: string);
    visitAccessScope(access: AccessScope): void;
}
}
declare module 'aurelia-validation/dist/amd/implementation/validation-parser' {
export * from '~aurelia-validation/dist/amd/implementation/validation-parser';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/aurelia/validation/0.13.1/dist/amd/implementation/validation-rules.d.ts
declare module '~aurelia-validation/dist/amd/implementation/validation-rules' {
import { Rule, RuleProperty } from '~aurelia-validation/dist/amd/implementation/rule';
import { ValidationParser, PropertyAccessor } from '~aurelia-validation/dist/amd/implementation/validation-parser';
/**
 * Part of the fluent rule API. Enables customizing property rules.
 */
export class FluentRuleCustomizer<TObject, TValue> {
    private fluentEnsure;
    private fluentRules;
    private parser;
    private rule;
    constructor(property: RuleProperty, condition: (value: TValue, object?: TObject) => boolean | Promise<boolean>, config: Object, fluentEnsure: FluentEnsure<TObject>, fluentRules: FluentRules<TObject, TValue>, parser: ValidationParser);
    /**
     * Validate subsequent rules after previously declared rules have
     * been validated successfully. Use to postpone validation of costly
     * rules until less expensive rules pass validation.
     */
    then(): this;
    /**
     * Specifies the key to use when looking up the rule's validation message.
     */
    withMessageKey(key: string): this;
    /**
     * Specifies rule's validation message.
     */
    withMessage(message: string): this;
    /**
     * Specifies a condition that must be met before attempting to validate the rule.
     * @param condition A function that accepts the object as a parameter and returns true
     * or false whether the rule should be evaluated.
     */
    when(condition: (object: TObject) => boolean): this;
    /**
     * Tags the rule instance, enabling the rule to be found easily
     * using ValidationRules.taggedRules(rules, tag)
     */
    tag(tag: string): this;
    /**
     * Target a property with validation rules.
     * @param property The property to target. Can be the property name or a property accessor function.
     */
    ensure<TValue2>(subject: string | {
        (model: TObject): TValue2;
    }): FluentRules<TObject, TValue2>;
    /**
     * Targets an object with validation rules.
     */
    ensureObject(): FluentRules<TObject, TObject>;
    /**
     * Rules that have been defined using the fluent API.
     */
    readonly rules: Rule<TObject, any>[][];
    /**
     * Applies the rules to a class or object, making them discoverable by the StandardValidator.
     * @param target A class or object.
     */
    on(target: any): FluentEnsure<TObject>;
    /**
     * Applies an ad-hoc rule function to the ensured property or object.
     * @param condition The function to validate the rule.
     * Will be called with two arguments, the property value and the object.
     * Should return a boolean or a Promise that resolves to a boolean.
     */
    satisfies(condition: (value: TValue, object?: TObject) => boolean | Promise<boolean>, config?: Object): FluentRuleCustomizer<TObject, TValue>;
    /**
     * Applies a rule by name.
     * @param name The name of the custom or standard rule.
     * @param args The rule's arguments.
     */
    satisfiesRule(name: string, ...args: any[]): FluentRuleCustomizer<TObject, TValue>;
    /**
     * Applies the "required" rule to the property.
     * The value cannot be null, undefined or whitespace.
     */
    required(): FluentRuleCustomizer<TObject, TValue>;
    /**
     * Applies the "matches" rule to the property.
     * Value must match the specified regular expression.
     * null, undefined and empty-string values are considered valid.
     */
    matches(regex: RegExp): FluentRuleCustomizer<TObject, TValue>;
    /**
     * Applies the "email" rule to the property.
     * null, undefined and empty-string values are considered valid.
     */
    email(): FluentRuleCustomizer<TObject, TValue>;
    /**
     * Applies the "minLength" STRING validation rule to the property.
     * null, undefined and empty-string values are considered valid.
     */
    minLength(length: number): FluentRuleCustomizer<TObject, TValue>;
    /**
     * Applies the "maxLength" STRING validation rule to the property.
     * null, undefined and empty-string values are considered valid.
     */
    maxLength(length: number): FluentRuleCustomizer<TObject, TValue>;
    /**
     * Applies the "minItems" ARRAY validation rule to the property.
     * null and undefined values are considered valid.
     */
    minItems(count: number): FluentRuleCustomizer<TObject, TValue>;
    /**
     * Applies the "maxItems" ARRAY validation rule to the property.
     * null and undefined values are considered valid.
     */
    maxItems(count: number): FluentRuleCustomizer<TObject, TValue>;
    /**
     * Applies the "equals" validation rule to the property.
     * null, undefined and empty-string values are considered valid.
     */
    equals(expectedValue: TValue): FluentRuleCustomizer<TObject, TValue>;
}
/**
 * Part of the fluent rule API. Enables applying rules to properties and objects.
 */
export class FluentRules<TObject, TValue> {
    private fluentEnsure;
    private parser;
    private property;
    static customRules: {
        [name: string]: {
            condition: (value: any, object?: any, ...fluentArgs: any[]) => boolean | Promise<boolean>;
            argsToConfig?: (...args: any[]) => any;
        };
    };
    constructor(fluentEnsure: FluentEnsure<TObject>, parser: ValidationParser, property: RuleProperty);
    /**
     * Sets the display name of the ensured property.
     */
    displayName(name: string): this;
    /**
     * Applies an ad-hoc rule function to the ensured property or object.
     * @param condition The function to validate the rule.
     * Will be called with two arguments, the property value and the object.
     * Should return a boolean or a Promise that resolves to a boolean.
     */
    satisfies(condition: (value: TValue, object?: TObject) => boolean | Promise<boolean>, config?: Object): FluentRuleCustomizer<TObject, TValue>;
    /**
     * Applies a rule by name.
     * @param name The name of the custom or standard rule.
     * @param args The rule's arguments.
     */
    satisfiesRule(name: string, ...args: any[]): FluentRuleCustomizer<TObject, TValue>;
    /**
     * Applies the "required" rule to the property.
     * The value cannot be null, undefined or whitespace.
     */
    required(): FluentRuleCustomizer<TObject, TValue>;
    /**
     * Applies the "matches" rule to the property.
     * Value must match the specified regular expression.
     * null, undefined and empty-string values are considered valid.
     */
    matches(regex: RegExp): FluentRuleCustomizer<TObject, TValue>;
    /**
     * Applies the "email" rule to the property.
     * null, undefined and empty-string values are considered valid.
     */
    email(): FluentRuleCustomizer<TObject, TValue>;
    /**
     * Applies the "minLength" STRING validation rule to the property.
     * null, undefined and empty-string values are considered valid.
     */
    minLength(length: number): FluentRuleCustomizer<TObject, TValue>;
    /**
     * Applies the "maxLength" STRING validation rule to the property.
     * null, undefined and empty-string values are considered valid.
     */
    maxLength(length: number): FluentRuleCustomizer<TObject, TValue>;
    /**
     * Applies the "minItems" ARRAY validation rule to the property.
     * null and undefined values are considered valid.
     */
    minItems(count: number): FluentRuleCustomizer<TObject, TValue>;
    /**
     * Applies the "maxItems" ARRAY validation rule to the property.
     * null and undefined values are considered valid.
     */
    maxItems(count: number): FluentRuleCustomizer<TObject, TValue>;
    /**
     * Applies the "equals" validation rule to the property.
     * null and undefined values are considered valid.
     */
    equals(expectedValue: TValue): FluentRuleCustomizer<TObject, TValue>;
}
/**
 * Part of the fluent rule API. Enables targeting properties and objects with rules.
 */
export class FluentEnsure<TObject> {
    private parser;
    /**
     * Rules that have been defined using the fluent API.
     */
    rules: Rule<TObject, any>[][];
    _sequence: number;
    constructor(parser: ValidationParser);
    /**
     * Target a property with validation rules.
     * @param property The property to target. Can be the property name or a property accessor function.
     */
    ensure<TValue>(property: string | PropertyAccessor<TObject, TValue>): FluentRules<TObject, TValue>;
    /**
     * Targets an object with validation rules.
     */
    ensureObject(): FluentRules<TObject, TObject>;
    /**
     * Applies the rules to a class or object, making them discoverable by the StandardValidator.
     * @param target A class or object.
     */
    on(target: any): this;
    /**
     * Adds a rule definition to the sequenced ruleset.
     */
    _addRule(rule: Rule<TObject, any>): void;
    private assertInitialized();
}
/**
 * Fluent rule definition API.
 */
export class ValidationRules {
    private static parser;
    static initialize(parser: ValidationParser): void;
    /**
     * Target a property with validation rules.
     * @param property The property to target. Can be the property name or a property accessor function.
     */
    static ensure<TObject, TValue>(property: string | PropertyAccessor<TObject, TValue>): FluentRules<TObject, TValue>;
    /**
     * Targets an object with validation rules.
     */
    static ensureObject<TObject>(): FluentRules<TObject, TObject>;
    /**
     * Defines a custom rule.
     * @param name The name of the custom rule. Also serves as the message key.
     * @param condition The rule function.
     * @param message The message expression
     * @param argsToConfig A function that maps the rule's arguments to a "config" object that can be used when evaluating the message expression.
     */
    static customRule(name: string, condition: (value: any, object?: any, ...args: any[]) => boolean | Promise<boolean>, message: string, argsToConfig?: (...args: any[]) => any): void;
    /**
     * Returns rules with the matching tag.
     * @param rules The rules to search.
     * @param tag The tag to search for.
     */
    static taggedRules(rules: Rule<any, any>[][], tag: string): Rule<any, any>[][];
    /**
     * Removes the rules from a class or object.
     * @param target A class or object.
     */
    static off(target: any): void;
}
}
declare module 'aurelia-validation/dist/amd/implementation/validation-rules' {
export * from '~aurelia-validation/dist/amd/implementation/validation-rules';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/aurelia/validation/0.13.1/dist/amd/aurelia-validation.d.ts
declare module '~aurelia-validation/dist/amd/aurelia-validation' {
export * from '~aurelia-validation/dist/amd/validate-binding-behavior';
export * from '~aurelia-validation/dist/amd/validate-trigger';
export * from '~aurelia-validation/dist/amd/validation-controller';
export * from '~aurelia-validation/dist/amd/validation-controller-factory';
export * from '~aurelia-validation/dist/amd/validation-error';
export * from '~aurelia-validation/dist/amd/validation-errors-custom-attribute';
export * from '~aurelia-validation/dist/amd/validation-renderer-custom-attribute';
export * from '~aurelia-validation/dist/amd/validation-renderer';
export * from '~aurelia-validation/dist/amd/validator';
export * from '~aurelia-validation/dist/amd/implementation/rule';
export * from '~aurelia-validation/dist/amd/implementation/rules';
export * from '~aurelia-validation/dist/amd/implementation/standard-validator';
export * from '~aurelia-validation/dist/amd/implementation/validation-messages';
export * from '~aurelia-validation/dist/amd/implementation/validation-parser';
export * from '~aurelia-validation/dist/amd/implementation/validation-rules';
import { Container } from 'aurelia-dependency-injection';
import { Validator } from '~aurelia-validation/dist/amd/validator';
/**
 * Aurelia Validation Configuration API
 */
export class AureliaValidationConfiguration {
    private validatorType;
    /**
     * Use a custom Validator implementation.
     */
    customValidator(type: {
        new (...args: any[]): Validator;
    }): void;
    /**
     * Applies the configuration.
     */
    apply(container: Container): void;
}
/**
 * Configures the plugin.
 */
export function configure(frameworkConfig: {
    container: Container;
    globalResources: (...resources: string[]) => any;
}, callback?: (config: AureliaValidationConfiguration) => void): void;
}
declare module 'aurelia-validation/dist/amd/aurelia-validation' {
export * from '~aurelia-validation/dist/amd/aurelia-validation';
}
declare module 'aurelia-validation' {
export * from '~aurelia-validation/dist/amd/aurelia-validation';
}
